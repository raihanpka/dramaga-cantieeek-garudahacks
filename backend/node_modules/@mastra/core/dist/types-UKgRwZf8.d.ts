import { z } from 'zod';

interface MetricResult {
    score: number;
    info?: Record<string, any>;
}
declare abstract class Metric {
    abstract measure(input: string, output: string): Promise<MetricResult>;
}

interface TestInfo {
    testName?: string;
    testPath?: string;
}
interface EvaluationResult extends MetricResult {
    output: string;
}

type ScoringSamplingConfig = {
    type: 'none';
} | {
    type: 'ratio';
    rate: number;
};
type ScoringSource = 'LIVE' | 'TEST';
type ScoringEntityType = 'AGENT' | 'WORKFLOW';
type ScoringPrompts = {
    description: string;
    prompt: string;
};
type ScoringInput = {
    runId: string;
    scorer: Record<string, any>;
    input: Record<string, any>[];
    output: Record<string, any>;
    metadata?: Record<string, any>;
    additionalContext?: Record<string, any>;
    source: ScoringSource;
    entity: Record<string, any>;
    entityType: ScoringEntityType;
    runtimeContext: Record<string, any>;
    structuredOutput?: boolean;
    traceId?: string;
    resourceId?: string;
    threadId?: string;
};
declare const scoringExtractStepResultSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
type ScoringExtractStepResult = z.infer<typeof scoringExtractStepResultSchema>;
declare const scoringValueSchema: z.ZodNumber;
declare const scoreResultSchema: z.ZodObject<{
    result: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    score: z.ZodNumber;
    prompt: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    score: number;
    result?: Record<string, any> | undefined;
    prompt?: string | undefined;
}, {
    score: number;
    result?: Record<string, any> | undefined;
    prompt?: string | undefined;
}>;
type ScoringAnalyzeStepResult = z.infer<typeof scoreResultSchema>;
type ScoringInputWithExtractStepResult<TExtract = any> = ScoringInput & {
    extractStepResult?: TExtract;
    extractPrompt?: string;
};
type ScoringInputWithExtractStepResultAndAnalyzeStepResult<TExtract = any, TScore = any> = ScoringInputWithExtractStepResult<TExtract> & {
    score: number;
    analyzeStepResult?: TScore;
    analyzePrompt?: string;
};
type ScoringInputWithExtractStepResultAndScoreAndReason = ScoringInputWithExtractStepResultAndAnalyzeStepResult & {
    reason?: string;
    reasonPrompt?: string;
};
type ScoreRowData = ScoringInputWithExtractStepResultAndScoreAndReason & {
    id: string;
    entityId: string;
    scorerId: string;
    createdAt: Date;
    updatedAt: Date;
};
type ExtractionStepFn = (input: ScoringInput) => Promise<Record<string, any>>;
type AnalyzeStepFn = (input: ScoringInputWithExtractStepResult) => Promise<ScoringAnalyzeStepResult>;
type ReasonStepFn = (input: ScoringInputWithExtractStepResultAndAnalyzeStepResult) => Promise<{
    reason: string;
    reasonPrompt?: string;
} | null>;
type ScorerOptions = {
    name: string;
    description: string;
    extract?: ExtractionStepFn;
    analyze: AnalyzeStepFn;
    reason?: ReasonStepFn;
    metadata?: Record<string, any>;
    isLLMScorer?: boolean;
};

export { type AnalyzeStepFn as A, type ExtractionStepFn as E, Metric as M, type ReasonStepFn as R, type ScoringInput as S, type TestInfo as T, type MetricResult as a, type ScorerOptions as b, type ScoringInputWithExtractStepResult as c, type ScoringSamplingConfig as d, type ScoringSource as e, type ScoringEntityType as f, type ScoringPrompts as g, type ScoringExtractStepResult as h, scoringValueSchema as i, scoreResultSchema as j, type ScoringAnalyzeStepResult as k, type ScoringInputWithExtractStepResultAndAnalyzeStepResult as l, type ScoringInputWithExtractStepResultAndScoreAndReason as m, type ScoreRowData as n, type EvaluationResult as o, scoringExtractStepResultSchema as s };
