import { p as VariableReference, q as StepResult, e as LegacyStep, L as LegacyWorkflow, A as Agent, W as WorkflowContext, T as ToolsInput, M as Mastra, r as StepAction, s as LegacyWorkflowRunResult } from '../../base-_bo5v6O4.cjs';
export { x as ActionContext, B as BaseCondition, O as DependencyCheckOutput, _ as ExtractSchemaFromStep, a1 as ExtractSchemaType, $ as ExtractStepResult, a3 as LegacyWorkflowRunState, Y as LegacyWorkflowState, a2 as PathsToStringProps, I as ResolverFunctionInput, J as ResolverFunctionOutput, R as RetryConfig, D as StepCondition, E as StepConfig, z as StepDef, S as StepExecutionContext, w as StepGraph, Z as StepId, a0 as StepInputType, v as StepNode, P as StepResolverOutput, u as StepVariableType, F as StepsRecord, K as SubscriberFunctionOutput, y as WhenConditionReturnValue, U as WorkflowActionParams, X as WorkflowActions, Q as WorkflowActors, H as WorkflowEvent, G as WorkflowLogMessage, t as WorkflowOptions, a4 as WorkflowResumeResult } from '../../base-_bo5v6O4.cjs';
import { z } from 'zod';
import { M as Metric } from '../../types-UKgRwZf8.cjs';
import { I as IMastraLogger } from '../../logger-B8XXh6ya.cjs';
import '../../telemetry-BEnuXKvd.cjs';
import 'ai';
import '../../base.cjs';
import '@opentelemetry/api';
import '../../runtime-context/index.cjs';
import 'json-schema';
import 'stream/web';
import 'sift';
import 'xstate';
import 'node:events';
import '../../vector/index.cjs';
import '../../vector/filter/index.cjs';
import '../../tts/index.cjs';
import '../../error/index.cjs';
import 'stream';
import '@opentelemetry/sdk-trace-base';
import 'ai/test';
import 'node:http';
import 'hono';
import 'events';
import 'node:stream/web';
import '../constants.cjs';
import '@ai-sdk/provider';
import '../../deployer/index.cjs';
import '../../bundler/index.cjs';
import 'hono/cors';
import 'hono-openapi';

declare function isErrorEvent(stateEvent: any): stateEvent is {
    type: `xstate.error.actor.${string}`;
    error: Error;
};
declare function isTransitionEvent(stateEvent: any): stateEvent is {
    type: `xstate.done.actor.${string}`;
    output?: unknown;
};
declare function isVariableReference(value: any): value is VariableReference<any, any>;
declare function getStepResult(result?: StepResult<any>): any;
declare function getSuspendedPaths({ value, path, suspendedPaths, }: {
    value: string | Record<string, string>;
    path: string;
    suspendedPaths: Set<string>;
}): void;
declare function isFinalState(status: string): boolean;
declare function isLimboState(status: string): boolean;
declare function recursivelyCheckForFinalState({ value, suspendedPaths, path, }: {
    value: string | Record<string, string>;
    suspendedPaths: Set<string>;
    path: string;
}): boolean;
declare function getActivePathsAndStatus(value: Record<string, any>): Array<{
    stepPath: string[];
    stepId: string;
    status: string;
}>;
declare function mergeChildValue(startStepId: string, parent: Record<string, any>, child: Record<string, any>): Record<string, any>;
declare const updateStepInHierarchy: (value: Record<string, any>, targetStepId: string) => Record<string, any>;
declare function getResultActivePaths(state: {
    value: Record<string, string>;
    context: {
        steps: Record<string, any>;
    };
}): Map<string, {
    status: string;
    suspendPayload?: any;
    stepPath: string[];
}>;
declare function isWorkflow(step: LegacyStep<any, any, any, any> | LegacyWorkflow<any, any, any, any> | Agent<any, any, any>): step is LegacyWorkflow<any, any, any, any>;
declare function isAgent(step: LegacyStep<any, any, any, any> | Agent<any, any, any> | LegacyWorkflow<any, any, any, any>): step is Agent<any, any, any>;
declare function resolveVariables({ runId, logger, variables, context, }: {
    runId: string;
    logger: IMastraLogger;
    variables: Record<string, VariableReference<any, any>>;
    context: WorkflowContext;
}): Record<string, any>;
declare function agentToStep<TAgentId extends string = string, TTools extends ToolsInput = ToolsInput, TMetrics extends Record<string, Metric> = Record<string, Metric>>(agent: Agent<TAgentId, TTools, TMetrics>, { mastra }?: {
    mastra?: Mastra;
}): StepAction<TAgentId, z.ZodObject<{
    prompt: z.ZodString;
}>, z.ZodObject<{
    text: z.ZodString;
}>, any>;
declare function workflowToStep<TSteps extends LegacyStep<any, any, any, any>[], TStepId extends string = any, TTriggerSchema extends z.ZodObject<any> = any, TResultSchema extends z.ZodObject<any> = any>(workflow: LegacyWorkflow<TSteps, TStepId, TTriggerSchema, TResultSchema>, { mastra }: {
    mastra?: Mastra;
}): StepAction<TStepId, TTriggerSchema, z.ZodType<LegacyWorkflowRunResult<TTriggerSchema, TSteps, TResultSchema>>, any>;
declare function isConditionalKey(key: string): boolean;

export { LegacyStep, LegacyWorkflow, LegacyWorkflowRunResult, StepAction, StepResult, VariableReference, WorkflowContext, agentToStep, getActivePathsAndStatus, getResultActivePaths, getStepResult, getSuspendedPaths, isAgent, isConditionalKey, isErrorEvent, isFinalState, isLimboState, isTransitionEvent, isVariableReference, isWorkflow, mergeChildValue, recursivelyCheckForFinalState, resolveVariables, updateStepInHierarchy, workflowToStep };
