import { createStep, createWorkflow } from '../chunk-GMJVVKKE.js';
import { Agent } from '../chunk-CDWNXPLT.js';
import { z } from 'zod';

var scoringExtractStepResultSchema = z.record(z.string(), z.any()).optional();
var scoringValueSchema = z.number();
var scoreResultSchema = z.object({
  result: z.record(z.string(), z.any()).optional(),
  score: scoringValueSchema,
  prompt: z.string().optional()
});
var MastraScorer = class {
  name;
  description;
  extract;
  analyze;
  reason;
  metadata;
  isLLMScorer;
  constructor(opts) {
    this.name = opts.name;
    this.description = opts.description;
    this.extract = opts.extract;
    this.analyze = opts.analyze;
    this.reason = opts.reason;
    this.metadata = {};
    this.isLLMScorer = opts.isLLMScorer;
    if (opts.metadata) {
      this.metadata = opts.metadata;
    }
  }
  async run(input) {
    const extractStep = createStep({
      id: "extract",
      description: "Extract relevant element from the run",
      inputSchema: z.any(),
      outputSchema: scoringExtractStepResultSchema,
      execute: async ({ inputData }) => {
        if (!this.extract) {
          return;
        }
        const extractStepResult = await this.extract(inputData);
        return extractStepResult;
      }
    });
    const analyzeStep = createStep({
      id: "analyze",
      description: "Score the extracted element",
      inputSchema: scoringExtractStepResultSchema,
      outputSchema: scoreResultSchema,
      execute: async ({ inputData }) => {
        const analyzeStepResult = await this.analyze({ ...input, extractStepResult: inputData?.result });
        return analyzeStepResult;
      }
    });
    const reasonStep = createStep({
      id: "reason",
      description: "Reason about the score",
      inputSchema: scoreResultSchema,
      outputSchema: z.any(),
      execute: async ({ getStepResult }) => {
        const analyzeStepRes = getStepResult(analyzeStep);
        const extractStepResult = getStepResult(extractStep);
        if (!this.reason) {
          return {
            extractStepResult: extractStepResult?.result,
            analyzeStepResult: analyzeStepRes?.result,
            analyzePrompt: analyzeStepRes?.prompt,
            extractPrompt: extractStepResult?.prompt,
            score: analyzeStepRes?.score
          };
        }
        const reasonResult = await this.reason({
          ...input,
          analyzeStepResult: analyzeStepRes.result,
          score: analyzeStepRes.score
        });
        return {
          extractStepResult: extractStepResult?.result,
          analyzeStepResult: analyzeStepRes?.result,
          analyzePrompt: analyzeStepRes?.prompt,
          extractPrompt: extractStepResult?.prompt,
          score: analyzeStepRes?.score,
          ...reasonResult
        };
      }
    });
    const scoringPipeline = createWorkflow({
      id: `scoring-pipeline-${this.name}`,
      inputSchema: z.any(),
      outputSchema: z.any(),
      steps: [extractStep, analyzeStep]
    }).then(extractStep).then(analyzeStep).then(reasonStep).commit();
    const workflowRun = await scoringPipeline.createRunAsync();
    const execution = await workflowRun.start({
      inputData: input
    });
    if (execution.status !== "success") {
      throw new Error(
        `Scoring pipeline failed: ${execution.status}`,
        execution.status === "failed" ? execution.error : void 0
      );
    }
    return { ...input, ...execution.result };
  }
};

// src/scores/code.ts
function createScorer(opts) {
  const scorer = new MastraScorer({
    name: opts.name,
    description: opts.description,
    extract: opts.extract,
    analyze: opts.analyze,
    reason: opts.reason
  });
  return scorer;
}
function createLLMScorer(opts) {
  const model = opts.judge.model;
  const llm = new Agent({
    name: opts.name,
    instructions: opts.judge.instructions,
    model
  });
  const scorer = new MastraScorer({
    name: opts.name,
    description: opts.description,
    metadata: opts,
    isLLMScorer: true,
    ...opts.extract && {
      extract: async (run) => {
        const prompt = opts.extract.createPrompt({ run });
        const extractResult = await llm.generate(prompt, {
          output: opts.extract.outputSchema
        });
        return {
          result: extractResult.object,
          prompt
        };
      }
    },
    analyze: async (run) => {
      const runWithExtractResult = {
        ...run,
        extractStepResult: run.extractStepResult
      };
      const prompt = opts.analyze.createPrompt({ run: runWithExtractResult });
      const analyzeResult = await llm.generate(prompt, {
        output: opts.analyze.outputSchema
      });
      let score = 0;
      const runWithScoreResult = {
        ...runWithExtractResult,
        analyzeStepResult: analyzeResult.object
      };
      if (opts.calculateScore) {
        score = opts.calculateScore({ run: runWithScoreResult });
      }
      runWithScoreResult.score = score;
      return {
        result: analyzeResult.object,
        score,
        prompt
      };
    },
    reason: opts.reason ? async (run) => {
      const runWithAllResults = {
        ...run,
        extractStepResult: run.extractStepResult,
        analyzeStepResult: run.analyzeStepResult,
        // Use results as fallback
        score: run.score || 0
      };
      const prompt = opts.reason?.createPrompt({ run: runWithAllResults });
      const reasonResult = await llm.generate(prompt, {
        output: z.object({
          reason: z.string()
        })
      });
      return {
        reason: reasonResult.object.reason,
        reasonPrompt: prompt
      };
    } : void 0
  });
  return scorer;
}

export { MastraScorer, createLLMScorer, createScorer, scoreResultSchema, scoringExtractStepResultSchema, scoringValueSchema };
