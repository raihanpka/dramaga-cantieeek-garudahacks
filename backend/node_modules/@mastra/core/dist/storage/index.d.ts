import { a9 as MastraStorage, aa as StorageDomains, ab as WorkflowRunState, ac as TABLE_NAMES, ad as StorageColumn, ae as StorageThreadType, af as StorageResourceType, ag as StorageGetMessagesArg, ah as MastraMessageV1, ai as MastraMessageV2, aj as PaginationInfo, ak as StorageGetTracesPaginatedArg, al as StoragePagination, am as PaginationArgs, an as EvalRow, ao as WorkflowRuns, ap as WorkflowRun, aq as ScoresStorage, ar as StoreOperations, as as StorageWorkflowRun, at as WorkflowsStorage, au as TracesStorage, av as StorageGetTracesArg, aw as StorageMessageType, ax as MemoryStorage } from '../base-AkychEpH.js';
export { aO as LegacyEvalsStorage, aC as LegacyWorkflowRun, aB as LegacyWorkflowRuns, aD as MastraMessageFormat, aM as SCORERS_SCHEMA, aE as StorageEvalRow, aG as TABLE_EVALS, aH as TABLE_MESSAGES, aK as TABLE_RESOURCES, aN as TABLE_SCHEMAS, aL as TABLE_SCORERS, aI as TABLE_THREADS, aJ as TABLE_TRACES, aF as TABLE_WORKFLOW_SNAPSHOT, ay as ensureDate, aA as resolveMessageLimit, az as serializeDate } from '../base-AkychEpH.js';
import { a as Trace } from '../telemetry-BEnuXKvd.js';
import { n as ScoreRowData } from '../types-UKgRwZf8.js';
import 'ai';
import '../base.js';
import '@opentelemetry/api';
import '../logger-Bpa2oLL4.js';
import '../error/index.js';
import 'stream';
import '../runtime-context/index.js';
import '@opentelemetry/sdk-trace-base';
import 'json-schema';
import 'zod';
import 'stream/web';
import 'sift';
import 'xstate';
import 'node:events';
import '../vector/index.js';
import '../vector/filter/index.js';
import '../tts/index.js';
import 'ai/test';
import 'node:http';
import 'hono';
import 'events';
import 'node:stream/web';
import '../workflows/constants.js';
import '@ai-sdk/provider';
import '../deployer/index.js';
import '../bundler/index.js';
import 'hono/cors';
import 'hono-openapi';

declare class InMemoryStore extends MastraStorage {
    stores: StorageDomains;
    constructor();
    persistWorkflowSnapshot({ workflowName, runId, snapshot, }: {
        workflowName: string;
        runId: string;
        snapshot: WorkflowRunState;
    }): Promise<void>;
    loadWorkflowSnapshot({ workflowName, runId, }: {
        workflowName: string;
        runId: string;
    }): Promise<WorkflowRunState | null>;
    createTable({ tableName, schema, }: {
        tableName: TABLE_NAMES;
        schema: Record<string, StorageColumn>;
    }): Promise<void>;
    alterTable({ tableName, schema, ifNotExists, }: {
        tableName: TABLE_NAMES;
        schema: Record<string, StorageColumn>;
        ifNotExists: string[];
    }): Promise<void>;
    clearTable({ tableName }: {
        tableName: TABLE_NAMES;
    }): Promise<void>;
    dropTable({ tableName }: {
        tableName: TABLE_NAMES;
    }): Promise<void>;
    insert({ tableName, record }: {
        tableName: TABLE_NAMES;
        record: Record<string, any>;
    }): Promise<void>;
    batchInsert({ tableName, records }: {
        tableName: TABLE_NAMES;
        records: Record<string, any>[];
    }): Promise<void>;
    load<R>({ tableName, keys }: {
        tableName: TABLE_NAMES;
        keys: Record<string, string>;
    }): Promise<R | null>;
    getThreadById({ threadId }: {
        threadId: string;
    }): Promise<StorageThreadType | null>;
    getThreadsByResourceId({ resourceId }: {
        resourceId: string;
    }): Promise<StorageThreadType[]>;
    saveThread({ thread }: {
        thread: StorageThreadType;
    }): Promise<StorageThreadType>;
    updateThread({ id, title, metadata, }: {
        id: string;
        title: string;
        metadata: Record<string, unknown>;
    }): Promise<StorageThreadType>;
    deleteThread({ threadId }: {
        threadId: string;
    }): Promise<void>;
    getResourceById({ resourceId }: {
        resourceId: string;
    }): Promise<StorageResourceType | null>;
    saveResource({ resource }: {
        resource: StorageResourceType;
    }): Promise<StorageResourceType>;
    updateResource({ resourceId, workingMemory, metadata, }: {
        resourceId: string;
        workingMemory?: string;
        metadata?: Record<string, unknown>;
    }): Promise<StorageResourceType>;
    getMessages(args: StorageGetMessagesArg & {
        format?: 'v1';
    }): Promise<MastraMessageV1[]>;
    getMessages(args: StorageGetMessagesArg & {
        format: 'v2';
    }): Promise<MastraMessageV2[]>;
    saveMessages(args: {
        messages: MastraMessageV1[];
        format?: undefined | 'v1';
    }): Promise<MastraMessageV1[]>;
    saveMessages(args: {
        messages: MastraMessageV2[];
        format: 'v2';
    }): Promise<MastraMessageV2[]>;
    updateMessages(args: {
        messages: Partial<MastraMessageV2> & {
            id: string;
        }[];
    }): Promise<MastraMessageV2[]>;
    getThreadsByResourceIdPaginated(args: {
        resourceId: string;
        page: number;
        perPage: number;
    }): Promise<PaginationInfo & {
        threads: StorageThreadType[];
    }>;
    getMessagesPaginated({ threadId, selectBy, }: StorageGetMessagesArg & {
        format?: 'v1' | 'v2';
    }): Promise<PaginationInfo & {
        messages: MastraMessageV1[] | MastraMessageV2[];
    }>;
    getTraces({ name, scope, page, perPage, attributes, filters, fromDate, toDate, }: {
        name?: string;
        scope?: string;
        page: number;
        perPage: number;
        attributes?: Record<string, string>;
        filters?: Record<string, any>;
        fromDate?: Date;
        toDate?: Date;
    }): Promise<any[]>;
    getTracesPaginated(args: StorageGetTracesPaginatedArg): Promise<PaginationInfo & {
        traces: Trace[];
    }>;
    batchTraceInsert(args: {
        records: Record<string, any>[];
    }): Promise<void>;
    getScoreById({ id }: {
        id: string;
    }): Promise<ScoreRowData | null>;
    saveScore(score: ScoreRowData): Promise<{
        score: ScoreRowData;
    }>;
    getScoresByScorerId({ scorerId, pagination, }: {
        scorerId: string;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    getScoresByRunId({ runId, pagination, }: {
        runId: string;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    getScoresByEntityId({ entityId, entityType, pagination, }: {
        entityId: string;
        entityType: string;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    getEvals(options: {
        agentName?: string;
        type?: 'test' | 'live';
    } & PaginationArgs): Promise<PaginationInfo & {
        evals: EvalRow[];
    }>;
    getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]>;
    getWorkflowRuns({ workflowName, fromDate, toDate, limit, offset, resourceId, }?: {
        workflowName?: string;
        fromDate?: Date;
        toDate?: Date;
        limit?: number;
        offset?: number;
        resourceId?: string;
    }): Promise<WorkflowRuns>;
    getWorkflowRunById({ runId, workflowName, }: {
        runId: string;
        workflowName?: string;
    }): Promise<WorkflowRun | null>;
}
declare const MockStore: typeof InMemoryStore;

type InMemoryScores = Map<string, ScoreRowData>;
declare class ScoresInMemory extends ScoresStorage {
    scores: InMemoryScores;
    constructor({ collection }: {
        collection: InMemoryScores;
    });
    getScoreById({ id }: {
        id: string;
    }): Promise<ScoreRowData | null>;
    saveScore(score: Omit<ScoreRowData, 'id' | 'createdAt' | 'updatedAt'>): Promise<{
        score: ScoreRowData;
    }>;
    getScoresByScorerId({ scorerId, pagination, entityId, entityType, }: {
        scorerId: string;
        pagination: StoragePagination;
        entityId?: string;
        entityType?: string;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    getScoresByRunId({ runId, pagination, }: {
        runId: string;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    getScoresByEntityId({ entityId, entityType, pagination, }: {
        entityId: string;
        entityType: string;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
}

declare class StoreOperationsInMemory extends StoreOperations {
    data: Record<TABLE_NAMES, Map<string, Record<string, any>>>;
    constructor();
    getDatabase(): Record<TABLE_NAMES, Map<string, Record<string, any>>>;
    insert({ tableName, record }: {
        tableName: TABLE_NAMES;
        record: Record<string, any>;
    }): Promise<void>;
    batchInsert({ tableName, records }: {
        tableName: TABLE_NAMES;
        records: Record<string, any>[];
    }): Promise<void>;
    load<R>({ tableName, keys }: {
        tableName: TABLE_NAMES;
        keys: Record<string, string>;
    }): Promise<R | null>;
    createTable({ tableName, schema, }: {
        tableName: TABLE_NAMES;
        schema: Record<string, StorageColumn>;
    }): Promise<void>;
    clearTable({ tableName }: {
        tableName: TABLE_NAMES;
    }): Promise<void>;
    dropTable({ tableName }: {
        tableName: TABLE_NAMES;
    }): Promise<void>;
    alterTable({ tableName, schema, }: {
        tableName: TABLE_NAMES;
        schema: Record<string, StorageColumn>;
        ifNotExists: string[];
    }): Promise<void>;
    hasColumn(table: string, column: string): Promise<boolean>;
}

type InMemoryWorkflows = Map<string, StorageWorkflowRun>;
declare class WorkflowsInMemory extends WorkflowsStorage {
    operations: StoreOperations;
    collection: InMemoryWorkflows;
    constructor({ collection, operations }: {
        collection: InMemoryWorkflows;
        operations: StoreOperations;
    });
    persistWorkflowSnapshot({ workflowName, runId, snapshot, }: {
        workflowName: string;
        runId: string;
        snapshot: WorkflowRunState;
    }): Promise<void>;
    loadWorkflowSnapshot({ workflowName, runId, }: {
        workflowName: string;
        runId: string;
    }): Promise<WorkflowRunState | null>;
    getWorkflowRuns({ workflowName, fromDate, toDate, limit, offset, resourceId, }?: {
        workflowName?: string;
        fromDate?: Date;
        toDate?: Date;
        limit?: number;
        offset?: number;
        resourceId?: string;
    }): Promise<WorkflowRuns>;
    getWorkflowRunById({ runId, workflowName, }: {
        runId: string;
        workflowName?: string;
    }): Promise<WorkflowRun | null>;
}

type InMemoryTraces = Map<string, Trace>;
declare class TracesInMemory extends TracesStorage {
    traces: InMemoryTraces;
    operations: StoreOperations;
    collection: InMemoryTraces;
    constructor({ collection, operations }: {
        collection: InMemoryTraces;
        operations: StoreOperations;
    });
    getTraces({ name, scope, page, perPage, attributes, filters, fromDate, toDate, }: StorageGetTracesArg): Promise<Trace[]>;
    getTracesPaginated({ name, scope, attributes, page, perPage, dateRange, }: StorageGetTracesPaginatedArg): Promise<PaginationInfo & {
        traces: Trace[];
    }>;
    batchTraceInsert({ records }: {
        records: Record<string, any>[];
    }): Promise<void>;
}

type InMemoryThreads = Map<string, StorageThreadType>;
type InMemoryResources = Map<string, StorageResourceType>;
type InMemoryMessages = Map<string, StorageMessageType>;
declare class InMemoryMemory extends MemoryStorage {
    private collection;
    private operations;
    constructor({ collection, operations, }: {
        collection: {
            threads: InMemoryThreads;
            resources: InMemoryResources;
            messages: InMemoryMessages;
        };
        operations: StoreOperations;
    });
    getThreadById({ threadId }: {
        threadId: string;
    }): Promise<StorageThreadType | null>;
    getThreadsByResourceId({ resourceId }: {
        resourceId: string;
    }): Promise<StorageThreadType[]>;
    saveThread({ thread }: {
        thread: StorageThreadType;
    }): Promise<StorageThreadType>;
    updateThread({ id, title, metadata, }: {
        id: string;
        title: string;
        metadata: Record<string, unknown>;
    }): Promise<StorageThreadType>;
    deleteThread({ threadId }: {
        threadId: string;
    }): Promise<void>;
    getMessages<T extends MastraMessageV2[]>({ threadId, selectBy }: StorageGetMessagesArg): Promise<T>;
    saveMessages(args: {
        messages: MastraMessageV1[];
        format?: undefined | 'v1';
    }): Promise<MastraMessageV1[]>;
    saveMessages(args: {
        messages: MastraMessageV2[];
        format: 'v2';
    }): Promise<MastraMessageV2[]>;
    updateMessages(args: {
        messages: (Partial<MastraMessageV2> & {
            id: string;
        })[];
    }): Promise<MastraMessageV2[]>;
    getThreadsByResourceIdPaginated(args: {
        resourceId: string;
        page: number;
        perPage: number;
    }): Promise<PaginationInfo & {
        threads: StorageThreadType[];
    }>;
    getMessagesPaginated({ threadId, selectBy, }: StorageGetMessagesArg & {
        format?: 'v1' | 'v2';
    }): Promise<PaginationInfo & {
        messages: MastraMessageV1[] | MastraMessageV2[];
    }>;
    getResourceById({ resourceId }: {
        resourceId: string;
    }): Promise<StorageResourceType | null>;
    saveResource({ resource }: {
        resource: StorageResourceType;
    }): Promise<StorageResourceType>;
    updateResource({ resourceId, workingMemory, metadata, }: {
        resourceId: string;
        workingMemory?: string;
        metadata?: Record<string, unknown>;
    }): Promise<StorageResourceType>;
}

declare function safelyParseJSON(jsonString: string): any;

export { EvalRow, InMemoryMemory, type InMemoryMessages, type InMemoryResources, type InMemoryScores, InMemoryStore, type InMemoryThreads, type InMemoryTraces, type InMemoryWorkflows, MastraStorage, MemoryStorage, MockStore, PaginationArgs, PaginationInfo, ScoresInMemory, ScoresStorage, StorageColumn, StorageDomains, StorageGetMessagesArg, StorageGetTracesArg, StorageGetTracesPaginatedArg, StorageMessageType, StoragePagination, StorageResourceType, StorageWorkflowRun, StoreOperations, StoreOperationsInMemory, TABLE_NAMES, TracesInMemory, TracesStorage, WorkflowRun, WorkflowRuns, WorkflowsInMemory, WorkflowsStorage, safelyParseJSON };
