import { MastraStorage } from '../chunk-6GPLJIFB.js';
export { MastraStorage, ensureDate, resolveMessageLimit, serializeDate } from '../chunk-6GPLJIFB.js';
import { MessageList } from '../chunk-6YZI5TWQ.js';
import { TABLE_WORKFLOW_SNAPSHOT, TABLE_EVALS, TABLE_TRACES } from '../chunk-H4LWPW7Q.js';
export { SCORERS_SCHEMA, TABLE_EVALS, TABLE_MESSAGES, TABLE_RESOURCES, TABLE_SCHEMAS, TABLE_SCORERS, TABLE_THREADS, TABLE_TRACES, TABLE_WORKFLOW_SNAPSHOT } from '../chunk-H4LWPW7Q.js';
import { MastraBase } from '../chunk-7OE6SJZL.js';

// src/storage/domains/legacy-evals/base.ts
var LegacyEvalsStorage = class extends MastraBase {
  constructor() {
    super({
      component: "STORAGE",
      name: "LEGACY_EVALS"
    });
  }
};

// src/storage/domains/legacy-evals/inmemory.ts
var InMemoryLegacyEvals = class extends LegacyEvalsStorage {
  collection;
  constructor({ collection }) {
    super();
    this.collection = collection;
  }
  async getEvals(options) {
    this.logger.debug(`MockStore: getEvals called`, options);
    let evals = Array.from(this.collection.values());
    if (options.agentName) {
      evals = evals.filter((evalR) => evalR.agent_name === options.agentName);
    }
    if (options.type === "test") {
      evals = evals.filter((evalR) => evalR.test_info && evalR.test_info.testPath);
    } else if (options.type === "live") {
      evals = evals.filter((evalR) => !evalR.test_info || !evalR.test_info.testPath);
    }
    if (options.dateRange?.start) {
      evals = evals.filter((evalR) => new Date(evalR.created_at) >= options.dateRange.start);
    }
    if (options.dateRange?.end) {
      evals = evals.filter((evalR) => new Date(evalR.created_at) <= options.dateRange.end);
    }
    evals.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
    const total = evals.length;
    const page = options.page || 0;
    const perPage = options.perPage || 100;
    const start = page * perPage;
    const end = start + perPage;
    return {
      evals: evals.slice(start, end).map((e) => ({
        agentName: e.agent_name,
        input: e.input,
        output: e.output,
        instructions: e.instructions,
        result: e.result,
        createdAt: e.created_at.toISOString(),
        testInfo: e.test_info,
        metricName: e.metric_name,
        runId: e.run_id,
        globalRunId: e.global_run_id
      })),
      total,
      page,
      perPage,
      hasMore: total > end
    };
  }
  async getEvalsByAgentName(agentName, type) {
    this.logger.debug(`MockStore: getEvalsByAgentName called for ${agentName}`);
    let evals = Array.from(this.collection.values()).filter((e) => e.agent_name === agentName);
    if (type === "test") {
      evals = evals.filter((e) => e.test_info && e.test_info.testPath);
    } else if (type === "live") {
      evals = evals.filter((e) => !e.test_info || !e.test_info.testPath);
    }
    return evals.sort(
      (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
    ).map((e) => ({
      agentName: e.agent_name,
      input: e.input,
      output: e.output,
      instructions: e.instructions,
      result: e.result,
      createdAt: e.created_at.toISOString(),
      metricName: e.metric_name,
      runId: e.run_id,
      testInfo: e.test_info,
      globalRunId: e.global_run_id
    }));
  }
};

// src/storage/domains/memory/base.ts
var MemoryStorage = class extends MastraBase {
  constructor() {
    super({
      component: "STORAGE",
      name: "MEMORY"
    });
  }
  async getResourceById(_) {
    throw new Error(
      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). To use per-resource working memory, switch to one of these supported storage adapters.`
    );
  }
  async saveResource(_) {
    throw new Error(
      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). To use per-resource working memory, switch to one of these supported storage adapters.`
    );
  }
  async updateResource(_) {
    throw new Error(
      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). To use per-resource working memory, switch to one of these supported storage adapters.`
    );
  }
};

// src/storage/domains/memory/inmemory.ts
var InMemoryMemory = class extends MemoryStorage {
  collection;
  operations;
  constructor({
    collection,
    operations
  }) {
    super();
    this.collection = collection;
    this.operations = operations;
  }
  async getThreadById({ threadId }) {
    this.logger.debug(`MockStore: getThreadById called for ${threadId}`);
    const thread = this.collection.threads.get(threadId);
    return thread ? { ...thread, metadata: thread.metadata ? { ...thread.metadata } : thread.metadata } : null;
  }
  async getThreadsByResourceId({ resourceId }) {
    this.logger.debug(`MockStore: getThreadsByResourceId called for ${resourceId}`);
    const threads = Array.from(this.collection.threads.values()).filter((t) => t.resourceId === resourceId);
    return threads.map((thread) => ({
      ...thread,
      metadata: thread.metadata ? { ...thread.metadata } : thread.metadata
    }));
  }
  async saveThread({ thread }) {
    this.logger.debug(`MockStore: saveThread called for ${thread.id}`);
    const key = thread.id;
    this.collection.threads.set(key, thread);
    return thread;
  }
  async updateThread({
    id,
    title,
    metadata
  }) {
    this.logger.debug(`MockStore: updateThread called for ${id}`);
    const thread = this.collection.threads.get(id);
    if (!thread) {
      throw new Error(`Thread with id ${id} not found`);
    }
    if (thread) {
      thread.title = title;
      thread.metadata = { ...thread.metadata, ...metadata };
      thread.updatedAt = /* @__PURE__ */ new Date();
    }
    return thread;
  }
  async deleteThread({ threadId }) {
    this.logger.debug(`MockStore: deleteThread called for ${threadId}`);
    this.collection.threads.delete(threadId);
    this.collection.messages.forEach((msg, key) => {
      if (msg.thread_id === threadId) {
        this.collection.messages.delete(key);
      }
    });
  }
  async getMessages({ threadId, selectBy }) {
    this.logger.debug(`MockStore: getMessages called for thread ${threadId}`);
    const messages = [];
    if (selectBy?.include && selectBy.include.length > 0) {
      for (const includeItem of selectBy.include) {
        const targetMessage = this.collection.messages.get(includeItem.id);
        if (targetMessage) {
          const convertedMessage = {
            id: targetMessage.id,
            threadId: targetMessage.thread_id,
            content: typeof targetMessage.content === "string" ? JSON.parse(targetMessage.content) : targetMessage.content,
            role: targetMessage.role,
            type: targetMessage.type,
            createdAt: targetMessage.createdAt,
            resourceId: targetMessage.resourceId
          };
          messages.push(convertedMessage);
          if (includeItem.withPreviousMessages) {
            const allThreadMessages = Array.from(this.collection.messages.values()).filter((msg) => msg.thread_id === includeItem.threadId).sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
            const targetIndex = allThreadMessages.findIndex((msg) => msg.id === includeItem.id);
            if (targetIndex !== -1) {
              const startIndex = Math.max(0, targetIndex - (includeItem.withPreviousMessages || 0));
              for (let i = startIndex; i < targetIndex; i++) {
                const message = allThreadMessages[i];
                if (message && !messages.some((m) => m.id === message.id)) {
                  const convertedPrevMessage = {
                    id: message.id,
                    threadId: message.thread_id,
                    content: typeof message.content === "string" ? JSON.parse(message.content) : message.content,
                    role: message.role,
                    type: message.type,
                    createdAt: message.createdAt,
                    resourceId: message.resourceId
                  };
                  messages.push(convertedPrevMessage);
                }
              }
            }
          }
          if (includeItem.withNextMessages) {
            const allThreadMessages = Array.from(this.collection.messages.values()).filter((msg) => msg.thread_id === includeItem.threadId).sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
            const targetIndex = allThreadMessages.findIndex((msg) => msg.id === includeItem.id);
            if (targetIndex !== -1) {
              const endIndex = Math.min(
                allThreadMessages.length,
                targetIndex + (includeItem.withNextMessages || 0) + 1
              );
              for (let i = targetIndex + 1; i < endIndex; i++) {
                const message = allThreadMessages[i];
                if (message && !messages.some((m) => m.id === message.id)) {
                  const convertedNextMessage = {
                    id: message.id,
                    threadId: message.thread_id,
                    content: typeof message.content === "string" ? JSON.parse(message.content) : message.content,
                    role: message.role,
                    type: message.type,
                    createdAt: message.createdAt,
                    resourceId: message.resourceId
                  };
                  messages.push(convertedNextMessage);
                }
              }
            }
          }
        }
      }
    }
    if (!selectBy?.include || selectBy.include.length === 0 || selectBy?.last) {
      let threadMessages = Array.from(this.collection.messages.values()).filter((msg) => msg.thread_id === threadId).filter((msg) => !messages.some((m) => m.id === msg.id));
      if (selectBy?.last) {
        threadMessages.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
        const lastMessages = threadMessages.slice(-selectBy.last);
        for (const msg of lastMessages) {
          const convertedMessage = {
            id: msg.id,
            threadId: msg.thread_id,
            content: typeof msg.content === "string" ? JSON.parse(msg.content) : msg.content,
            role: msg.role,
            type: msg.type,
            createdAt: msg.createdAt,
            resourceId: msg.resourceId
          };
          messages.push(convertedMessage);
        }
      } else if (!selectBy?.include || selectBy.include.length === 0) {
        for (const msg of threadMessages) {
          const convertedMessage = {
            id: msg.id,
            threadId: msg.thread_id,
            content: typeof msg.content === "string" ? JSON.parse(msg.content) : msg.content,
            role: msg.role,
            type: msg.type,
            createdAt: msg.createdAt,
            resourceId: msg.resourceId
          };
          messages.push(convertedMessage);
        }
      }
    }
    messages.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
    return messages;
  }
  async saveMessages(args) {
    const { messages, format = "v1" } = args;
    this.logger.debug(`MockStore: saveMessages called with ${messages.length} messages`);
    if (messages.some((msg) => msg.id === "error-message" || msg.resourceId === null)) {
      throw new Error("Simulated error for testing");
    }
    const threadIds = new Set(messages.map((msg) => msg.threadId).filter((id) => Boolean(id)));
    for (const threadId of threadIds) {
      const thread = this.collection.threads.get(threadId);
      if (thread) {
        thread.updatedAt = /* @__PURE__ */ new Date();
      }
    }
    for (const message of messages) {
      const key = message.id;
      const storageMessage = {
        id: message.id,
        thread_id: message.threadId || "",
        content: typeof message.content === "string" ? message.content : JSON.stringify(message.content),
        role: message.role || "user",
        type: message.type || "text",
        createdAt: message.createdAt,
        resourceId: message.resourceId || null
      };
      this.collection.messages.set(key, storageMessage);
    }
    const list = new MessageList().add(messages, "memory");
    if (format === `v2`) return list.get.all.v2();
    return list.get.all.v1();
  }
  async updateMessages(args) {
    const updatedMessages = [];
    for (const update of args.messages) {
      const storageMsg = this.collection.messages.get(update.id);
      if (!storageMsg) continue;
      const oldThreadId = storageMsg.thread_id;
      const newThreadId = update.threadId || oldThreadId;
      let threadIdChanged = false;
      if (update.threadId && update.threadId !== oldThreadId) {
        threadIdChanged = true;
      }
      if (update.role !== void 0) storageMsg.role = update.role;
      if (update.type !== void 0) storageMsg.type = update.type;
      if (update.createdAt !== void 0) storageMsg.createdAt = update.createdAt;
      if (update.resourceId !== void 0) storageMsg.resourceId = update.resourceId;
      if (update.content !== void 0) {
        let oldContent = typeof storageMsg.content === "string" ? JSON.parse(storageMsg.content) : storageMsg.content;
        let newContent = update.content;
        if (typeof newContent === "object" && typeof oldContent === "object") {
          newContent = { ...oldContent, ...newContent };
          if (oldContent.metadata && newContent.metadata) {
            newContent.metadata = { ...oldContent.metadata, ...newContent.metadata };
          }
        }
        storageMsg.content = JSON.stringify(newContent);
      }
      if (threadIdChanged) {
        storageMsg.thread_id = newThreadId;
        const base = Date.now();
        let oldThreadNewTime;
        const oldThread = this.collection.threads.get(oldThreadId);
        if (oldThread) {
          const prev = new Date(oldThread.updatedAt).getTime();
          oldThreadNewTime = Math.max(base, prev + 1);
          oldThread.updatedAt = new Date(oldThreadNewTime);
        }
        const newThread = this.collection.threads.get(newThreadId);
        if (newThread) {
          const prev = new Date(newThread.updatedAt).getTime();
          let newThreadNewTime = Math.max(base + 1, prev + 1);
          if (oldThreadNewTime !== void 0 && newThreadNewTime <= oldThreadNewTime) {
            newThreadNewTime = oldThreadNewTime + 1;
          }
          newThread.updatedAt = new Date(newThreadNewTime);
        }
      } else {
        const thread = this.collection.threads.get(oldThreadId);
        if (thread) {
          const prev = new Date(thread.updatedAt).getTime();
          let newTime = Date.now();
          if (newTime <= prev) newTime = prev + 1;
          thread.updatedAt = new Date(newTime);
        }
      }
      this.collection.messages.set(update.id, storageMsg);
      updatedMessages.push({
        id: storageMsg.id,
        threadId: storageMsg.thread_id,
        content: typeof storageMsg.content === "string" ? JSON.parse(storageMsg.content) : storageMsg.content,
        role: storageMsg.role === "user" || storageMsg.role === "assistant" ? storageMsg.role : "user",
        type: storageMsg.type,
        createdAt: storageMsg.createdAt,
        resourceId: storageMsg.resourceId === null ? void 0 : storageMsg.resourceId
      });
    }
    return updatedMessages;
  }
  async getThreadsByResourceIdPaginated(args) {
    this.logger.debug(`MockStore: getThreadsByResourceIdPaginated called for ${args.resourceId}`);
    const threads = Array.from(this.collection.threads.values()).filter((t) => t.resourceId === args.resourceId);
    const clonedThreads = threads.map((thread) => ({
      ...thread,
      metadata: thread.metadata ? { ...thread.metadata } : thread.metadata
    }));
    return {
      threads: clonedThreads.slice(args.page * args.perPage, (args.page + 1) * args.perPage),
      total: clonedThreads.length,
      page: args.page,
      perPage: args.perPage,
      hasMore: clonedThreads.length > (args.page + 1) * args.perPage
    };
  }
  async getMessagesPaginated({
    threadId,
    selectBy
  }) {
    this.logger.debug(`MockStore: getMessagesPaginated called for thread ${threadId}`);
    const { page = 0, perPage = 40 } = selectBy?.pagination || {};
    const messages = [];
    if (selectBy?.include && selectBy.include.length > 0) {
      for (const includeItem of selectBy.include) {
        const targetMessage = this.collection.messages.get(includeItem.id);
        if (targetMessage) {
          const convertedMessage = {
            id: targetMessage.id,
            threadId: targetMessage.thread_id,
            content: typeof targetMessage.content === "string" ? JSON.parse(targetMessage.content) : targetMessage.content,
            role: targetMessage.role,
            type: targetMessage.type,
            createdAt: targetMessage.createdAt,
            resourceId: targetMessage.resourceId
          };
          messages.push(convertedMessage);
          if (includeItem.withPreviousMessages) {
            const allThreadMessages = Array.from(this.collection.messages.values()).filter((msg) => msg.thread_id === includeItem.threadId).sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
            const targetIndex = allThreadMessages.findIndex((msg) => msg.id === includeItem.id);
            if (targetIndex !== -1) {
              const startIndex = Math.max(0, targetIndex - (includeItem.withPreviousMessages || 0));
              for (let i = startIndex; i < targetIndex; i++) {
                const message = allThreadMessages[i];
                if (message && !messages.some((m) => m.id === message.id)) {
                  const convertedPrevMessage = {
                    id: message.id,
                    threadId: message.thread_id,
                    content: typeof message.content === "string" ? JSON.parse(message.content) : message.content,
                    role: message.role,
                    type: message.type,
                    createdAt: message.createdAt,
                    resourceId: message.resourceId
                  };
                  messages.push(convertedPrevMessage);
                }
              }
            }
          }
          if (includeItem.withNextMessages) {
            const allThreadMessages = Array.from(this.collection.messages.values()).filter((msg) => msg.thread_id === includeItem.threadId).sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
            const targetIndex = allThreadMessages.findIndex((msg) => msg.id === includeItem.id);
            if (targetIndex !== -1) {
              const endIndex = Math.min(
                allThreadMessages.length,
                targetIndex + (includeItem.withNextMessages || 0) + 1
              );
              for (let i = targetIndex + 1; i < endIndex; i++) {
                const message = allThreadMessages[i];
                if (message && !messages.some((m) => m.id === message.id)) {
                  const convertedNextMessage = {
                    id: message.id,
                    threadId: message.thread_id,
                    content: typeof message.content === "string" ? JSON.parse(message.content) : message.content,
                    role: message.role,
                    type: message.type,
                    createdAt: message.createdAt,
                    resourceId: message.resourceId
                  };
                  messages.push(convertedNextMessage);
                }
              }
            }
          }
        }
      }
    }
    if (!selectBy?.include || selectBy.include.length === 0 || selectBy?.last) {
      let threadMessages = Array.from(this.collection.messages.values()).filter((msg) => msg.thread_id === threadId).filter((msg) => !messages.some((m) => m.id === msg.id));
      if (selectBy?.pagination?.dateRange) {
        const { start: from, end: to } = selectBy.pagination.dateRange;
        threadMessages = threadMessages.filter((msg) => {
          const msgDate = new Date(msg.createdAt);
          const fromDate = from ? new Date(from) : null;
          const toDate = to ? new Date(to) : null;
          if (fromDate && msgDate < fromDate) return false;
          if (toDate && msgDate > toDate) return false;
          return true;
        });
      }
      if (selectBy?.last) {
        threadMessages.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
        const lastMessages = threadMessages.slice(-selectBy.last);
        for (const msg of lastMessages) {
          const convertedMessage = {
            id: msg.id,
            threadId: msg.thread_id,
            content: typeof msg.content === "string" ? JSON.parse(msg.content) : msg.content,
            role: msg.role,
            type: msg.type,
            createdAt: msg.createdAt,
            resourceId: msg.resourceId
          };
          messages.push(convertedMessage);
        }
      } else if (!selectBy?.include || selectBy.include.length === 0) {
        for (const msg of threadMessages) {
          const convertedMessage = {
            id: msg.id,
            threadId: msg.thread_id,
            content: typeof msg.content === "string" ? JSON.parse(msg.content) : msg.content,
            role: msg.role,
            type: msg.type,
            createdAt: msg.createdAt,
            resourceId: msg.resourceId
          };
          messages.push(convertedMessage);
        }
      }
    }
    messages.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
    const start = page * perPage;
    const end = start + perPage;
    return {
      messages: messages.slice(start, end),
      total: messages.length,
      page,
      perPage,
      hasMore: messages.length > end
    };
  }
  async getResourceById({ resourceId }) {
    this.logger.debug(`MockStore: getResourceById called for ${resourceId}`);
    const resource = this.collection.resources.get(resourceId);
    return resource ? { ...resource, metadata: resource.metadata ? { ...resource.metadata } : resource.metadata } : null;
  }
  async saveResource({ resource }) {
    this.logger.debug(`MockStore: saveResource called for ${resource.id}`);
    this.collection.resources.set(resource.id, resource);
    return resource;
  }
  async updateResource({
    resourceId,
    workingMemory,
    metadata
  }) {
    this.logger.debug(`MockStore: updateResource called for ${resourceId}`);
    let resource = this.collection.resources.get(resourceId);
    if (!resource) {
      resource = {
        id: resourceId,
        workingMemory,
        metadata: metadata || {},
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
    } else {
      resource = {
        ...resource,
        workingMemory: workingMemory !== void 0 ? workingMemory : resource.workingMemory,
        metadata: {
          ...resource.metadata,
          ...metadata
        },
        updatedAt: /* @__PURE__ */ new Date()
      };
    }
    this.collection.resources.set(resourceId, resource);
    return resource;
  }
};

// src/storage/domains/operations/base.ts
var StoreOperations = class extends MastraBase {
  constructor() {
    super({
      component: "STORAGE",
      name: "OPERATIONS"
    });
  }
  getSqlType(type) {
    switch (type) {
      case "text":
        return "TEXT";
      case "timestamp":
        return "TIMESTAMP";
      case "float":
        return "FLOAT";
      case "integer":
        return "INTEGER";
      case "bigint":
        return "BIGINT";
      case "jsonb":
        return "JSONB";
      case "float":
        return "FLOAT";
      default:
        return "TEXT";
    }
  }
  getDefaultValue(type) {
    switch (type) {
      case "text":
      case "uuid":
        return "DEFAULT ''";
      case "timestamp":
        return "DEFAULT '1970-01-01 00:00:00'";
      case "integer":
      case "bigint":
      case "float":
        return "DEFAULT 0";
      case "jsonb":
        return "DEFAULT '{}'";
      default:
        return "DEFAULT ''";
    }
  }
};

// src/storage/domains/operations/inmemory.ts
var StoreOperationsInMemory = class extends StoreOperations {
  data;
  constructor() {
    super();
    this.data = {
      mastra_workflow_snapshot: /* @__PURE__ */ new Map(),
      mastra_evals: /* @__PURE__ */ new Map(),
      mastra_messages: /* @__PURE__ */ new Map(),
      mastra_threads: /* @__PURE__ */ new Map(),
      mastra_traces: /* @__PURE__ */ new Map(),
      mastra_resources: /* @__PURE__ */ new Map(),
      mastra_scorers: /* @__PURE__ */ new Map()
    };
  }
  getDatabase() {
    return this.data;
  }
  async insert({ tableName, record }) {
    console.log(`[insert] tableName: ${tableName}, record:`, record);
    const table = this.data[tableName];
    let key = record.id;
    if ([TABLE_WORKFLOW_SNAPSHOT, TABLE_EVALS].includes(tableName) && !record.id && record.run_id) {
      key = record.run_id;
      record.id = key;
    } else if (!record.id) {
      key = `auto-${Date.now()}-${Math.random()}`;
      record.id = key;
    }
    console.log(`[insert] Using key: ${key}`);
    table.set(key, record);
  }
  async batchInsert({ tableName, records }) {
    console.log(`[batchInsert] tableName: ${tableName}, records:`, records);
    const table = this.data[tableName];
    for (const record of records) {
      let key = record.id;
      if ([TABLE_WORKFLOW_SNAPSHOT, TABLE_EVALS].includes(tableName) && !record.id && record.run_id) {
        key = record.run_id;
        record.id = key;
      } else if (!record.id) {
        key = `auto-${Date.now()}-${Math.random()}`;
        record.id = key;
      }
      console.log(`[batchInsert] Using key: ${key}`);
      table.set(key, record);
    }
  }
  async load({ tableName, keys }) {
    this.logger.debug(`MockStore: load called for ${tableName} with keys`, keys);
    const table = this.data[tableName];
    const records = Array.from(table.values());
    return records.filter((record) => Object.keys(keys).every((key) => record[key] === keys[key]))?.[0];
  }
  async createTable({
    tableName,
    schema
  }) {
    this.logger.debug(`MockStore: createTable called for ${tableName} with schema`, schema);
    this.data[tableName] = /* @__PURE__ */ new Map();
  }
  async clearTable({ tableName }) {
    this.logger.debug(`MockStore: clearTable called for ${tableName}`);
    this.data[tableName].clear();
  }
  async dropTable({ tableName }) {
    this.logger.debug(`MockStore: dropTable called for ${tableName}`);
    this.data[tableName].clear();
  }
  async alterTable({
    tableName,
    schema
  }) {
    this.logger.debug(`MockStore: alterTable called for ${tableName} with schema`, schema);
  }
  async hasColumn(table, column) {
    this.logger.debug(`MockStore: hasColumn called for ${table} with column ${column}`);
    return true;
  }
};

// src/storage/domains/scores/base.ts
var ScoresStorage = class extends MastraBase {
  constructor() {
    super({
      component: "STORAGE",
      name: "SCORES"
    });
  }
};

// src/storage/domains/scores/inmemory.ts
var ScoresInMemory = class extends ScoresStorage {
  scores;
  constructor({ collection }) {
    super();
    this.scores = collection;
  }
  async getScoreById({ id }) {
    return this.scores.get(id) ?? null;
  }
  async saveScore(score) {
    const newScore = { id: crypto.randomUUID(), createdAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date(), ...score };
    this.scores.set(newScore.id, newScore);
    return { score: newScore };
  }
  async getScoresByScorerId({
    scorerId,
    pagination,
    entityId,
    entityType
  }) {
    const scores = Array.from(this.scores.values()).filter((score) => {
      let baseFilter = score.scorerId === scorerId;
      if (entityId) {
        baseFilter = baseFilter && score.entityId === entityId;
      }
      if (entityType) {
        baseFilter = baseFilter && score.entityType === entityType;
      }
      return baseFilter;
    });
    return {
      scores: scores.slice(pagination.page * pagination.perPage, (pagination.page + 1) * pagination.perPage),
      pagination: {
        total: scores.length,
        page: pagination.page,
        perPage: pagination.perPage,
        hasMore: scores.length > (pagination.page + 1) * pagination.perPage
      }
    };
  }
  async getScoresByRunId({
    runId,
    pagination
  }) {
    const scores = Array.from(this.scores.values()).filter((score) => score.runId === runId);
    return {
      scores: scores.slice(pagination.page * pagination.perPage, (pagination.page + 1) * pagination.perPage),
      pagination: {
        total: scores.length,
        page: pagination.page,
        perPage: pagination.perPage,
        hasMore: scores.length > (pagination.page + 1) * pagination.perPage
      }
    };
  }
  async getScoresByEntityId({
    entityId,
    entityType,
    pagination
  }) {
    const scores = Array.from(this.scores.values()).filter((score) => {
      const baseFilter = score.entityId === entityId && score.entityType === entityType;
      return baseFilter;
    });
    return {
      scores: scores.slice(pagination.page * pagination.perPage, (pagination.page + 1) * pagination.perPage),
      pagination: {
        total: scores.length,
        page: pagination.page,
        perPage: pagination.perPage,
        hasMore: scores.length > (pagination.page + 1) * pagination.perPage
      }
    };
  }
};

// src/storage/domains/traces/base.ts
var TracesStorage = class extends MastraBase {
  constructor() {
    super({
      component: "STORAGE",
      name: "TRACES"
    });
  }
};

// src/storage/domains/traces/inmemory.ts
var TracesInMemory = class extends TracesStorage {
  traces;
  operations;
  collection;
  constructor({ collection, operations }) {
    super();
    this.collection = collection;
    this.traces = collection;
    this.operations = operations;
  }
  async getTraces({
    name,
    scope,
    page,
    perPage,
    attributes,
    filters,
    fromDate,
    toDate
  }) {
    this.logger.debug(`MockStore: getTraces called`);
    let traces = Array.from(this.collection.values());
    if (name) traces = traces.filter((t) => t.name?.startsWith(name));
    if (scope) traces = traces.filter((t) => t.scope === scope);
    if (attributes) {
      traces = traces.filter(
        (t) => Object.entries(attributes).every(([key, value]) => t.attributes?.[key] === value)
      );
    }
    if (filters) {
      traces = traces.filter((t) => Object.entries(filters).every(([key, value]) => t[key] === value));
    }
    if (fromDate) traces = traces.filter((t) => new Date(t.createdAt) >= fromDate);
    if (toDate) traces = traces.filter((t) => new Date(t.createdAt) <= toDate);
    traces.sort((a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());
    const start = page * perPage;
    const end = start + perPage;
    return traces.slice(start, end);
  }
  async getTracesPaginated({
    name,
    scope,
    attributes,
    page = 0,
    perPage = 10,
    dateRange
  }) {
    this.logger.debug(`MockStore: getTracesPaginated called`);
    let traces = Array.from(this.collection.values());
    if (name) traces = traces.filter((t) => t.name?.startsWith(name));
    if (scope) traces = traces.filter((t) => t.scope === scope);
    if (attributes) {
      traces = traces.filter(
        (t) => Object.entries(attributes).every(([key, value]) => t.attributes?.[key] === value)
      );
    }
    if (dateRange?.start) traces = traces.filter((t) => new Date(t.createdAt) >= dateRange.start);
    if (dateRange?.end) traces = traces.filter((t) => new Date(t.createdAt) <= dateRange.end);
    traces.sort((a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());
    const start = page * perPage;
    const end = start + perPage;
    return {
      traces: traces.slice(start, end),
      total: traces.length,
      page,
      perPage,
      hasMore: traces.length > end
    };
  }
  async batchTraceInsert({ records }) {
    this.logger.debug("Batch inserting traces", { count: records.length });
    await this.operations.batchInsert({
      tableName: TABLE_TRACES,
      records
    });
  }
};

// src/storage/domains/workflows/base.ts
var WorkflowsStorage = class extends MastraBase {
  constructor() {
    super({
      component: "STORAGE",
      name: "WORKFLOWS"
    });
  }
};

// src/storage/domains/workflows/inmemory.ts
var WorkflowsInMemory = class extends WorkflowsStorage {
  operations;
  collection;
  constructor({ collection, operations }) {
    super();
    this.collection = collection;
    this.operations = operations;
  }
  async persistWorkflowSnapshot({
    workflowName,
    runId,
    snapshot
  }) {
    const data = {
      workflow_name: workflowName,
      run_id: runId,
      snapshot,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    console.log("[persistWorkflowSnapshot] args:", { workflowName, runId, snapshot });
    console.log("[persistWorkflowSnapshot] data:", data);
    await this.operations.insert({
      tableName: TABLE_WORKFLOW_SNAPSHOT,
      record: data
    });
  }
  async loadWorkflowSnapshot({
    workflowName,
    runId
  }) {
    this.logger.debug("Loading workflow snapshot", { workflowName, runId });
    const d = await this.operations.load({
      tableName: TABLE_WORKFLOW_SNAPSHOT,
      keys: { workflow_name: workflowName, run_id: runId }
    });
    return d ? JSON.parse(JSON.stringify(d.snapshot)) : null;
  }
  async getWorkflowRuns({
    workflowName,
    fromDate,
    toDate,
    limit,
    offset,
    resourceId
  } = {}) {
    console.log(`[getWorkflowRuns] called with`, { workflowName, fromDate, toDate, limit, offset, resourceId });
    let runs = Array.from(this.collection.values());
    console.log(`[getWorkflowRuns] initial runs:`, runs);
    if (workflowName) runs = runs.filter((run) => run.workflow_name === workflowName);
    if (fromDate && toDate) {
      runs = runs.filter(
        (run) => new Date(run.createdAt).getTime() >= fromDate.getTime() && new Date(run.createdAt).getTime() <= toDate.getTime()
      );
    } else if (fromDate) {
      runs = runs.filter((run) => new Date(run.createdAt).getTime() >= fromDate.getTime());
    } else if (toDate) {
      runs = runs.filter((run) => new Date(run.createdAt).getTime() <= toDate.getTime());
    }
    if (resourceId) runs = runs.filter((run) => run.resourceId === resourceId);
    console.log(`[getWorkflowRuns] after filtering:`, runs);
    const total = runs.length;
    runs.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    if (limit !== void 0 && offset !== void 0) {
      const start = offset;
      const end = start + limit;
      runs = runs.slice(start, end);
    }
    const parsedRuns = runs.map((run) => ({
      ...run,
      snapshot: typeof run.snapshot === "string" ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),
      createdAt: new Date(run.createdAt),
      updatedAt: new Date(run.updatedAt),
      runId: run.run_id,
      workflowName: run.workflow_name
    }));
    console.log(`[getWorkflowRuns] parsedRuns:`, parsedRuns);
    return { runs: parsedRuns, total };
  }
  async getWorkflowRunById({
    runId,
    workflowName
  }) {
    console.log(`[getWorkflowRunById] called for runId ${runId}, workflowName ${workflowName}`);
    let run = Array.from(this.collection.values()).find((r) => r.run_id === runId);
    if (run && workflowName && run.workflow_name !== workflowName) {
      run = void 0;
    }
    if (!run) return null;
    const parsedRun = {
      ...run,
      snapshot: typeof run.snapshot === "string" ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),
      createdAt: new Date(run.createdAt),
      updatedAt: new Date(run.updatedAt),
      runId: run.run_id,
      workflowName: run.workflow_name
    };
    console.log(`[getWorkflowRunById] parsedRun:`, parsedRun);
    return parsedRun;
  }
};

// src/storage/mock.ts
var InMemoryStore = class extends MastraStorage {
  stores;
  constructor() {
    super({ name: "InMemoryStorage" });
    this.hasInitialized = Promise.resolve(true);
    const operationsStorage = new StoreOperationsInMemory();
    const database = operationsStorage.getDatabase();
    const scoresStorage = new ScoresInMemory({
      collection: database.mastra_scorers
    });
    const workflowsStorage = new WorkflowsInMemory({
      collection: database.mastra_workflow_snapshot,
      operations: operationsStorage
    });
    const tracesStorage = new TracesInMemory({
      collection: database.mastra_traces,
      operations: operationsStorage
    });
    const memoryStorage = new InMemoryMemory({
      collection: {
        threads: database.mastra_threads,
        resources: database.mastra_resources,
        messages: database.mastra_messages
      },
      operations: operationsStorage
    });
    const legacyEvalsStorage = new InMemoryLegacyEvals({
      collection: database.mastra_evals
    });
    this.stores = {
      legacyEvals: legacyEvalsStorage,
      operations: operationsStorage,
      workflows: workflowsStorage,
      traces: tracesStorage,
      scores: scoresStorage,
      memory: memoryStorage
    };
  }
  async persistWorkflowSnapshot({
    workflowName,
    runId,
    snapshot
  }) {
    await this.stores.workflows.persistWorkflowSnapshot({ workflowName, runId, snapshot });
  }
  async loadWorkflowSnapshot({
    workflowName,
    runId
  }) {
    return this.stores.workflows.loadWorkflowSnapshot({ workflowName, runId });
  }
  async createTable({
    tableName,
    schema
  }) {
    await this.stores.operations.createTable({ tableName, schema });
  }
  async alterTable({
    tableName,
    schema,
    ifNotExists
  }) {
    await this.stores.operations.alterTable({ tableName, schema, ifNotExists });
  }
  async clearTable({ tableName }) {
    await this.stores.operations.clearTable({ tableName });
  }
  async dropTable({ tableName }) {
    await this.stores.operations.dropTable({ tableName });
  }
  async insert({ tableName, record }) {
    await this.stores.operations.insert({ tableName, record });
  }
  async batchInsert({ tableName, records }) {
    await this.stores.operations.batchInsert({ tableName, records });
  }
  async load({ tableName, keys }) {
    return this.stores.operations.load({ tableName, keys });
  }
  async getThreadById({ threadId }) {
    return this.stores.memory.getThreadById({ threadId });
  }
  async getThreadsByResourceId({ resourceId }) {
    return this.stores.memory.getThreadsByResourceId({ resourceId });
  }
  async saveThread({ thread }) {
    return this.stores.memory.saveThread({ thread });
  }
  async updateThread({
    id,
    title,
    metadata
  }) {
    return this.stores.memory.updateThread({ id, title, metadata });
  }
  async deleteThread({ threadId }) {
    return this.stores.memory.deleteThread({ threadId });
  }
  async getResourceById({ resourceId }) {
    return this.stores.memory.getResourceById({ resourceId });
  }
  async saveResource({ resource }) {
    return this.stores.memory.saveResource({ resource });
  }
  async updateResource({
    resourceId,
    workingMemory,
    metadata
  }) {
    return this.stores.memory.updateResource({ resourceId, workingMemory, metadata });
  }
  async getMessages({
    threadId,
    resourceId,
    selectBy,
    format
  }) {
    return this.stores.memory.getMessages({ threadId, resourceId, selectBy, format });
  }
  async saveMessages(args) {
    return this.stores.memory.saveMessages(args);
  }
  async updateMessages(args) {
    return this.stores.memory.updateMessages(args);
  }
  async getThreadsByResourceIdPaginated(args) {
    return this.stores.memory.getThreadsByResourceIdPaginated(args);
  }
  async getMessagesPaginated({
    threadId,
    selectBy
  }) {
    return this.stores.memory.getMessagesPaginated({ threadId, selectBy });
  }
  async getTraces({
    name,
    scope,
    page,
    perPage,
    attributes,
    filters,
    fromDate,
    toDate
  }) {
    return this.stores.traces.getTraces({ name, scope, page, perPage, attributes, filters, fromDate, toDate });
  }
  async getTracesPaginated(args) {
    return this.stores.traces.getTracesPaginated(args);
  }
  async batchTraceInsert(args) {
    return this.stores.traces.batchTraceInsert(args);
  }
  async getScoreById({ id }) {
    return this.stores.scores.getScoreById({ id });
  }
  async saveScore(score) {
    return this.stores.scores.saveScore(score);
  }
  async getScoresByScorerId({
    scorerId,
    pagination
  }) {
    return this.stores.scores.getScoresByScorerId({ scorerId, pagination });
  }
  async getScoresByRunId({
    runId,
    pagination
  }) {
    return this.stores.scores.getScoresByRunId({ runId, pagination });
  }
  async getScoresByEntityId({
    entityId,
    entityType,
    pagination
  }) {
    return this.stores.scores.getScoresByEntityId({ entityId, entityType, pagination });
  }
  async getEvals(options) {
    return this.stores.legacyEvals.getEvals(options);
  }
  async getEvalsByAgentName(agentName, type) {
    return this.stores.legacyEvals.getEvalsByAgentName(agentName, type);
  }
  async getWorkflowRuns({
    workflowName,
    fromDate,
    toDate,
    limit,
    offset,
    resourceId
  } = {}) {
    return this.stores.workflows.getWorkflowRuns({ workflowName, fromDate, toDate, limit, offset, resourceId });
  }
  async getWorkflowRunById({
    runId,
    workflowName
  }) {
    return this.stores.workflows.getWorkflowRunById({ runId, workflowName });
  }
};
var MockStore = InMemoryStore;

// src/storage/domains/index.ts
function safelyParseJSON(jsonString) {
  try {
    return JSON.parse(jsonString);
  } catch {
    return {};
  }
}

export { InMemoryMemory, InMemoryStore, LegacyEvalsStorage, MemoryStorage, MockStore, ScoresInMemory, ScoresStorage, StoreOperations, StoreOperationsInMemory, TracesInMemory, TracesStorage, WorkflowsInMemory, WorkflowsStorage, safelyParseJSON };
