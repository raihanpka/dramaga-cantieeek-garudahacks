import { validateBody } from './chunk-RSEO4XPX.js';
import { handleError } from './chunk-LF7P5PLR.js';
import { HTTPException } from './chunk-LCM566I4.js';
import { __export } from './chunk-MLKGABMK.js';
import { generateEmptyFromSchema } from '@mastra/core';

// src/server/handlers/memory.ts
var memory_exports = {};
__export(memory_exports, {
  createThreadHandler: () => createThreadHandler,
  deleteThreadHandler: () => deleteThreadHandler,
  getMemoryConfigHandler: () => getMemoryConfigHandler,
  getMemoryStatusHandler: () => getMemoryStatusHandler,
  getMessagesHandler: () => getMessagesHandler,
  getMessagesPaginatedHandler: () => getMessagesPaginatedHandler,
  getThreadByIdHandler: () => getThreadByIdHandler,
  getThreadsHandler: () => getThreadsHandler,
  getWorkingMemoryHandler: () => getWorkingMemoryHandler,
  saveMessagesHandler: () => saveMessagesHandler,
  searchMemoryHandler: () => searchMemoryHandler,
  updateThreadHandler: () => updateThreadHandler,
  updateWorkingMemoryHandler: () => updateWorkingMemoryHandler
});
async function getMemoryFromContext({
  mastra,
  agentId,
  networkId,
  runtimeContext
}) {
  const agent = agentId ? mastra.getAgent(agentId) : null;
  if (agentId && !agent) {
    throw new HTTPException(404, { message: "Agent not found" });
  }
  const network = networkId ? mastra.vnext_getNetwork(networkId) : null;
  if (networkId && !network) {
    throw new HTTPException(404, { message: "Network not found" });
  }
  if (agent) {
    return await agent?.getMemory() || mastra.getMemory();
  }
  if (network) {
    return await network?.getMemory({ runtimeContext }) || mastra.getMemory();
  }
  return mastra.getMemory();
}
async function getMemoryStatusHandler({
  mastra,
  agentId,
  networkId,
  runtimeContext
}) {
  try {
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      return { result: false };
    }
    return { result: true };
  } catch (error) {
    return handleError(error, "Error getting memory status");
  }
}
async function getMemoryConfigHandler({
  mastra,
  agentId,
  networkId,
  runtimeContext
}) {
  try {
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    const config = memory.getMergedThreadConfig({});
    return { config };
  } catch (error) {
    return handleError(error, "Error getting memory configuration");
  }
}
async function getThreadsHandler({
  mastra,
  agentId,
  resourceId,
  networkId,
  runtimeContext
}) {
  try {
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    validateBody({ resourceId });
    const threads = await memory.getThreadsByResourceId({ resourceId });
    return threads;
  } catch (error) {
    return handleError(error, "Error getting threads");
  }
}
async function getThreadByIdHandler({
  mastra,
  agentId,
  threadId,
  networkId,
  runtimeContext
}) {
  try {
    validateBody({ threadId });
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    const thread = await memory.getThreadById({ threadId });
    if (!thread) {
      throw new HTTPException(404, { message: "Thread not found" });
    }
    return thread;
  } catch (error) {
    return handleError(error, "Error getting thread");
  }
}
async function saveMessagesHandler({
  mastra,
  agentId,
  body,
  networkId,
  runtimeContext
}) {
  try {
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    if (!body?.messages) {
      throw new HTTPException(400, { message: "Messages are required" });
    }
    if (!Array.isArray(body.messages)) {
      throw new HTTPException(400, { message: "Messages should be an array" });
    }
    const invalidMessages = body.messages.filter((message) => !message.threadId || !message.resourceId);
    if (invalidMessages.length > 0) {
      throw new HTTPException(400, {
        message: `All messages must have threadId and resourceId fields. Found ${invalidMessages.length} invalid message(s).`
      });
    }
    const processedMessages = body.messages.map((message) => ({
      ...message,
      id: message.id || memory.generateId(),
      createdAt: message.createdAt ? new Date(message.createdAt) : /* @__PURE__ */ new Date()
    }));
    const result = await memory.saveMessages({ messages: processedMessages, memoryConfig: {} });
    return result;
  } catch (error) {
    return handleError(error, "Error saving messages");
  }
}
async function createThreadHandler({
  mastra,
  agentId,
  body,
  networkId,
  runtimeContext
}) {
  try {
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    validateBody({ resourceId: body?.resourceId });
    const result = await memory.createThread({
      resourceId: body?.resourceId,
      title: body?.title,
      metadata: body?.metadata,
      threadId: body?.threadId
    });
    return result;
  } catch (error) {
    return handleError(error, "Error saving thread to memory");
  }
}
async function updateThreadHandler({
  mastra,
  agentId,
  threadId,
  body,
  networkId,
  runtimeContext
}) {
  try {
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!body) {
      throw new HTTPException(400, { message: "Body is required" });
    }
    const { title, metadata, resourceId } = body;
    const updatedAt = /* @__PURE__ */ new Date();
    validateBody({ threadId });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    const thread = await memory.getThreadById({ threadId });
    if (!thread) {
      throw new HTTPException(404, { message: "Thread not found" });
    }
    const updatedThread = {
      ...thread,
      title: title || thread.title,
      metadata: metadata || thread.metadata,
      resourceId: resourceId || thread.resourceId,
      createdAt: thread.createdAt,
      updatedAt
    };
    const result = await memory.saveThread({ thread: updatedThread });
    return result;
  } catch (error) {
    return handleError(error, "Error updating thread");
  }
}
async function deleteThreadHandler({
  mastra,
  agentId,
  threadId,
  networkId,
  runtimeContext
}) {
  try {
    validateBody({ threadId });
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    const thread = await memory.getThreadById({ threadId });
    if (!thread) {
      throw new HTTPException(404, { message: "Thread not found" });
    }
    await memory.deleteThread(threadId);
    return { result: "Thread deleted" };
  } catch (error) {
    return handleError(error, "Error deleting thread");
  }
}
async function getMessagesPaginatedHandler({
  mastra,
  threadId,
  resourceId,
  selectBy,
  format
}) {
  try {
    validateBody({ threadId });
    const storage = mastra.getStorage();
    if (!storage) {
      throw new HTTPException(400, { message: "Storage is not initialized" });
    }
    const thread = await storage.getThreadById({ threadId });
    if (!thread) {
      throw new HTTPException(404, { message: "Thread not found" });
    }
    const result = await storage.getMessagesPaginated({ threadId, resourceId, selectBy, format });
    return result;
  } catch (error) {
    return handleError(error, "Error getting messages");
  }
}
async function getMessagesHandler({
  mastra,
  agentId,
  threadId,
  limit,
  networkId,
  runtimeContext
}) {
  if (limit !== void 0 && (!Number.isInteger(limit) || limit <= 0)) {
    throw new HTTPException(400, { message: "Invalid limit: must be a positive integer" });
  }
  try {
    validateBody({ threadId });
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    const thread = await memory.getThreadById({ threadId });
    if (!thread) {
      throw new HTTPException(404, { message: "Thread not found" });
    }
    const result = await memory.query({
      threadId,
      ...limit && { selectBy: { last: limit } }
    });
    return { messages: result.messages, uiMessages: result.uiMessages };
  } catch (error) {
    return handleError(error, "Error getting messages");
  }
}
async function getWorkingMemoryHandler({
  mastra,
  agentId,
  threadId,
  resourceId,
  networkId,
  runtimeContext,
  memoryConfig
}) {
  try {
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    validateBody({ threadId });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    const thread = await memory.getThreadById({ threadId });
    const threadExists = !!thread;
    const template = await memory.getWorkingMemoryTemplate({ memoryConfig });
    const workingMemoryTemplate = template?.format === "json" ? { ...template, content: JSON.stringify(generateEmptyFromSchema(template.content)) } : template;
    const workingMemory = await memory.getWorkingMemory({ threadId, resourceId, memoryConfig });
    const config = memory.getMergedThreadConfig(memoryConfig || {});
    const source = config.workingMemory?.scope === "resource" && resourceId ? "resource" : "thread";
    return { workingMemory, source, workingMemoryTemplate, threadExists };
  } catch (error) {
    return handleError(error, "Error getting working memory");
  }
}
async function updateWorkingMemoryHandler({
  mastra,
  agentId,
  threadId,
  body,
  networkId,
  runtimeContext
}) {
  try {
    validateBody({ threadId });
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    const { resourceId, memoryConfig, workingMemory } = body;
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    const thread = await memory.getThreadById({ threadId });
    if (!thread) {
      throw new HTTPException(404, { message: "Thread not found" });
    }
    await memory.updateWorkingMemory({ threadId, resourceId, workingMemory, memoryConfig });
    return { success: true };
  } catch (error) {
    return handleError(error, "Error updating working memory");
  }
}
async function searchMemoryHandler({
  mastra,
  agentId,
  searchQuery,
  resourceId,
  threadId,
  limit = 20,
  networkId,
  runtimeContext,
  memoryConfig
}) {
  try {
    validateBody({ searchQuery, resourceId });
    const memory = await getMemoryFromContext({ mastra, agentId, networkId, runtimeContext });
    if (!memory) {
      throw new HTTPException(400, { message: "Memory is not initialized" });
    }
    const config = memory.getMergedThreadConfig(memoryConfig || {});
    const hasSemanticRecall = !!config?.semanticRecall;
    const resourceScope = typeof config?.semanticRecall === "object" && config?.semanticRecall?.scope === "resource";
    if (threadId && !resourceScope) {
      const thread = await memory.getThreadById({ threadId });
      if (!thread) {
        throw new HTTPException(404, { message: "Thread not found" });
      }
      if (thread.resourceId !== resourceId) {
        throw new HTTPException(403, { message: "Thread does not belong to the specified resource" });
      }
    }
    const searchResults = [];
    const messageMap = /* @__PURE__ */ new Map();
    if (threadId && !resourceScope) {
      const thread = await memory.getThreadById({ threadId });
      if (!thread) {
        return {
          results: [],
          count: 0,
          query: searchQuery,
          searchScope: "thread",
          searchType: hasSemanticRecall ? "semantic" : "text"
        };
      }
    }
    if (!threadId || resourceScope) {
      const threads = await memory.getThreadsByResourceId({ resourceId });
      if (threads.length === 0) {
        return {
          results: [],
          count: 0,
          query: searchQuery,
          searchScope: "resource",
          searchType: hasSemanticRecall ? "semantic" : "text"
        };
      }
      for (const thread of threads) {
        const result = await memory.rememberMessages({
          threadId: thread.id,
          resourceId,
          vectorMessageSearch: searchQuery,
          config
        });
        const threadMessages = (await memory.query({ threadId: thread.id })).uiMessages;
        result.messagesV2.forEach((msg) => {
          if (messageMap.has(msg.id)) return;
          messageMap.set(msg.id, true);
          const content = msg.content.content || msg.content.parts?.map((p) => p.type === "text" ? p.text : "").join(" ") || "";
          if (!hasSemanticRecall && !content.toLowerCase().includes(searchQuery.toLowerCase())) {
            return;
          }
          const messageIndex = threadMessages.findIndex((m) => m.id === msg.id);
          const searchResult = {
            id: msg.id,
            role: msg.role,
            content,
            createdAt: msg.createdAt,
            threadId: msg.threadId || thread.id,
            threadTitle: thread.title || msg.threadId || thread.id
          };
          if (messageIndex !== -1) {
            searchResult.context = {
              before: threadMessages.slice(Math.max(0, messageIndex - 2), messageIndex).map((m) => ({
                id: m.id,
                role: m.role,
                content: m.content,
                createdAt: m.createdAt || /* @__PURE__ */ new Date()
              })),
              after: threadMessages.slice(messageIndex + 1, messageIndex + 3).map((m) => ({
                id: m.id,
                role: m.role,
                content: m.content,
                createdAt: m.createdAt || /* @__PURE__ */ new Date()
              }))
            };
          }
          searchResults.push(searchResult);
        });
      }
    } else if (threadId) {
      const thread = await memory.getThreadById({ threadId });
      if (!thread) {
        return {
          results: [],
          count: 0,
          query: searchQuery,
          searchScope: "thread",
          searchType: hasSemanticRecall ? "semantic" : "text"
        };
      }
      const result = await memory.rememberMessages({
        threadId,
        resourceId,
        vectorMessageSearch: searchQuery,
        config
      });
      const threadMessages = (await memory.query({ threadId })).uiMessages;
      result.messagesV2.forEach((msg) => {
        if (messageMap.has(msg.id)) return;
        messageMap.set(msg.id, true);
        const content = msg.content.content || msg.content.parts?.map((p) => p.type === "text" ? p.text : "").join(" ") || "";
        if (!hasSemanticRecall && !content.toLowerCase().includes(searchQuery.toLowerCase())) {
          return;
        }
        const messageIndex = threadMessages.findIndex((m) => m.id === msg.id);
        const searchResult = {
          id: msg.id,
          role: msg.role,
          content,
          createdAt: msg.createdAt,
          threadId,
          threadTitle: thread?.title || threadId
        };
        if (messageIndex !== -1) {
          searchResult.context = {
            before: threadMessages.slice(Math.max(0, messageIndex - 2), messageIndex).map((m) => ({
              id: m.id,
              role: m.role,
              content: m.content,
              createdAt: m.createdAt || /* @__PURE__ */ new Date()
            })),
            after: threadMessages.slice(messageIndex + 1, messageIndex + 3).map((m) => ({
              id: m.id,
              role: m.role,
              content: m.content,
              createdAt: m.createdAt || /* @__PURE__ */ new Date()
            }))
          };
        }
        searchResults.push(searchResult);
      });
    }
    const sortedResults = searchResults.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, limit);
    return {
      results: sortedResults,
      count: sortedResults.length,
      query: searchQuery,
      searchScope: resourceScope ? "resource" : "thread",
      searchType: hasSemanticRecall ? "semantic" : "text"
    };
  } catch (error) {
    return handleError(error, "Error searching memory");
  }
}

export { createThreadHandler, deleteThreadHandler, getMemoryConfigHandler, getMemoryStatusHandler, getMessagesHandler, getMessagesPaginatedHandler, getThreadByIdHandler, getThreadsHandler, getWorkingMemoryHandler, memory_exports, saveMessagesHandler, searchMemoryHandler, updateThreadHandler, updateWorkingMemoryHandler };
